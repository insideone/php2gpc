<?php

const ALL_REMAPS = 0;


/**
 * persistent variable
 */
const PVAR_1 = 0;

/**
 * persistent variable
 */
const PVAR_5 = 0;

/**
 * persistent variable
 */
const PVAR_9 = 0;

/**
 * persistent variable
 */
const PVAR_13 = 0;

/**
 * persistent variable
 */
const PVAR_2 = 0;

/**
 * persistent variable
 */
const PVAR_6 = 0;

/**
 * persistent variable
 */
const PVAR_10 = 0;

/**
 * persistent variable
 */
const PVAR_14 = 0;

/**
 * persistent variable
 */
const PVAR_3 = 0;

/**
 * persistent variable
 */
const PVAR_7 = 0;

/**
 * persistent variable
 */
const PVAR_11 = 0;

/**
 * persistent variable
 */
const PVAR_15 = 0;

/**
 * persistent variable
 */
const PVAR_4 = 0;

/**
 * persistent variable
 */
const PVAR_8 = 0;

/**
 * persistent variable
 */
const PVAR_12 = 0;

/**
 * persistent variable
 */
const PVAR_16 = 0;


/**
 * persistent slot variable
 */
const SPVAR_1 = 0;

/**
 * persistent slot variable
 */
const SPVAR_5 = 0;

/**
 * persistent slot variable
 */
const SPVAR_9 = 0;

/**
 * persistent slot variable
 */
const SPVAR_13 = 0;

/**
 * persistent slot variable
 */
const SPVAR_2 = 0;

/**
 * persistent slot variable
 */
const SPVAR_6 = 0;

/**
 * persistent slot variable
 */
const SPVAR_10 = 0;

/**
 * persistent slot variable
 */
const SPVAR_14 = 0;

/**
 * persistent slot variable
 */
const SPVAR_3 = 0;

/**
 * persistent slot variable
 */
const SPVAR_7 = 0;

/**
 * persistent slot variable
 */
const SPVAR_11 = 0;

/**
 * persistent slot variable
 */
const SPVAR_15 = 0;

/**
 * persistent slot variable
 */
const SPVAR_4 = 0;

/**
 * persistent slot variable
 */
const SPVAR_8 = 0;

/**
 * persistent slot variable
 */
const SPVAR_12 = 0;

/**
 * persistent slot variable
 */
const SPVAR_16 = 0;


/**
 * Playstation 3 Controller
 */
const PIO_PS3 = 1;

/**
 * Xbox 360 Controller
 */
const PIO_XB360 = 2;

/**
 * Wii Controller
 */
const PIO_WII = 3;

/**
 * Playstation 4 Controller
 */
const PIO_PS4 = 4;

/**
 * Xbox One Controller
 */
const PIO_XB1 = 5;

/**
 * LED 1 / Xbox 360 Quadrant 1
 */
const LED_1 = 0;

/**
 * LED 2 / Xbox 360 Quadrant 2
 */
const LED_2 = 1;

/**
 * LED 3 / Xbox 360 Quadrant 3
 */
const LED_3 = 2;

/**
 * LED 4 / Xbox 360 Quadrant 4
 */
const LED_4 = 3;

/**
 * TRUE if at least one finger is on the touchpad, FALSE if none
 */
const PS4T_P1 = 1;

/**
 * X axis value of the first finger on the touchpad
 */
const PS4T_P1X = 2;

/**
 * Y axis value of the first finger on the touchpad
 */
const PS4T_P1Y = 3;

/**
 * TRUE if two fingers are on the touchpad, FALSE if less than two.
 */
const PS4T_P2 = 16;

/**
 * X axis value of the second finger on the touchpad
 */
const PS4T_P2X = 32;

/**
 * Y axis value of the second finger on the touchpad
 */
const PS4T_P2Y = 48;

/**
 * Strong Rumble Motor (Usually the Left Motor)
 */
const RUMBLE_A = 0;
/**
 * Weak Rumble Motor (Usually the Right Motor)
 */
const RUMBLE_B = 1;
/**
 * Right Trigger Motor (Xbox One controllers only)
 */
const RUMBLE_RT = 2;
/**
 * Left Trigger Motor (Xbox One controllers only)
 */
const RUMBLE_LT = 3;

/**
 * button
 */
const PS4_PS = 0;

/**
 * button
 */
const PS4_SHARE = 0;

/**
 * button
 */
const PS4_OPTIONS = 0;

/**
 * button
 */
const PS4_R1 = 0;

/**
 * button
 */
const PS4_R2 = 0;

/**
 * button
 */
const PS4_R3 = 0;

/**
 * button
 */
const PS4_L1 = 0;

/**
 * button
 */
const PS4_L2 = 0;

/**
 * button
 */
const PS4_L3 = 0;

/**
 * button
 */
const PS4_RX = 0;

/**
 * button
 */
const PS4_RY = 0;

/**
 * button
 */
const PS4_LX = 0;

/**
 * button
 */
const PS4_LY = 0;

/**
 * button
 */
const PS4_UP = 0;

/**
 * button
 */
const PS4_DOWN = 0;

/**
 * button
 */
const PS4_LEFT = 0;

/**
 * button
 */
const PS4_RIGHT = 0;

/**
 * button
 */
const PS4_TRIANGLE = 0;

/**
 * button
 */
const PS4_CIRCLE = 0;

/**
 * button
 */
const PS4_CROSS = 0;

/**
 * button
 */
const PS4_SQUARE = 0;

/**
 * button
 */
const PS4_ACCX = 0;

/**
 * button
 */
const PS4_ACCY = 0;

/**
 * button
 */
const PS4_ACCZ = 0;

/**
 * button
 */
const PS4_GYROX = 0;

/**
 * button
 */
const PS4_GYROY = 0;

/**
 * button
 */
const PS4_GYROZ = 0;

/**
 * button
 */
const PS4_TOUCH = 0;

/**
 * button
 */
const PS4_TOUCHX = 0;

/**
 * button
 */
const PS4_TOUCHY = 0;

/**
 * button
 */
const PS3_PS = 0;

/**
 * button
 */
const PS3_SELECT = 0;

/**
 * button
 */
const PS3_START = 0;

/**
 * button
 */
const PS3_R1 = 0;

/**
 * button
 */
const PS3_R2 = 0;

/**
 * button
 */
const PS3_R3 = 0;

/**
 * button
 */
const PS3_L1 = 0;

/**
 * button
 */
const PS3_L2 = 0;

/**
 * button
 */
const PS3_L3 = 0;

/**
 * button
 */
const PS3_RX = 0;

/**
 * button
 */
const PS3_RY = 0;

/**
 * button
 */
const PS3_LX = 0;

/**
 * button
 */
const PS3_LY = 0;

/**
 * button
 */
const PS3_UP = 0;

/**
 * button
 */
const PS3_DOWN = 0;

/**
 * button
 */
const PS3_LEFT = 0;

/**
 * button
 */
const PS3_RIGHT = 0;

/**
 * button
 */
const PS3_TRIANGLE = 0;

/**
 * button
 */
const PS3_CIRCLE = 0;

/**
 * button
 */
const PS3_CROSS = 0;

/**
 * button
 */
const PS3_SQUARE = 0;

/**
 * button
 */
const PS3_ACCX = 0;

/**
 * button
 */
const PS3_ACCY = 0;

/**
 * button
 */
const PS3_ACCZ = 0;

/**
 * button
 */
const PS3_GYRO = 0;

/**
 * button
 */
const XB360_XBOX = 0;

/**
 * button
 */
const XB360_BACK = 0;

/**
 * button
 */
const XB360_START = 0;

/**
 * button
 */
const XB360_RB = 0;

/**
 * button
 */
const XB360_RT = 0;

/**
 * button
 */
const XB360_RS = 0;

/**
 * button
 */
const XB360_LB = 0;

/**
 * button
 */
const XB360_LT = 0;

/**
 * button
 */
const XB360_LS = 0;

/**
 * button
 */
const XB360_RX = 0;

/**
 * button
 */
const XB360_RY = 0;

/**
 * button
 */
const XB360_LX = 0;

/**
 * button
 */
const XB360_LY = 0;

/**
 * button
 */
const XB360_UP = 0;

/**
 * button
 */
const XB360_DOWN = 0;

/**
 * button
 */
const XB360_LEFT = 0;

/**
 * button
 */
const XB360_RIGHT = 0;

/**
 * button
 */
const XB360_Y = 0;

/**
 * button
 */
const XB360_B = 0;

/**
 * button
 */
const XB360_A = 0;

/**
 * button
 */
const XB360_X = 0;

/**
 * button
 */
const WII_HOME = 0;

/**
 * button
 */
const WII_MINUS = 0;

/**
 * button
 */
const WII_PLUS = 0;

/**
 * button
 */
const WII_RT = 0;

/**
 * button
 */
const WII_ZR = 0;

/**
 * button
 */
const WII_ONE = 0;

/**
 * button
 */
const WII_TWO = 0;

/**
 * button
 */
const WII_C = 0;

/**
 * button
 */
const WII_Z = 0;

/**
 * button
 */
const WII_LT = 0;

/**
 * button
 */
const WII_ZL = 0;

/**
 * button
 */
const WII_RX = 0;

/**
 * button
 */
const WII_RY = 0;

/**
 * button
 */
const WII_NX = 0;

/**
 * button
 */
const WII_NY = 0;

/**
 * button
 */
const WII_LX = 0;

/**
 * button
 */
const WII_LY = 0;

/**
 * button
 */
const WII_UP = 0;

/**
 * button
 */
const WII_DOWN = 0;

/**
 * button
 */
const WII_LEFT = 0;

/**
 * button
 */
const WII_RIGHT = 0;

/**
 * button
 */
const WII_B = 0;

/**
 * button
 */
const WII_A = 0;

/**
 * button
 */
const WII_X = 0;

/**
 * button
 */
const WII_Y = 0;

/**
 * button
 */
const WII_ACCX = 0;

/**
 * button
 */
const WII_ACCY = 0;

/**
 * button
 */
const WII_ACCZ = 0;

/**
 * button
 */
const WII_ACCNX = 0;

/**
 * button
 */
const WII_ACCNY = 0;

/**
 * button
 */
const WII_ACCNZ = 0;

/**
 * button
 */
const WII_IRX = 0;

/**
 * button
 */
const WII_IRY = 0;


/**
 * remap button
 * @param int $to
 * @param int $from
 */
function remap($to, $from) {}

/**
 * unmap remapping
 * @param int $btn
 */
function unmap($btn) {}

/**
 * output_reconnection forces the CronusMAX PLUS to electronically disconnect the output port from the console and then
 * reconnect again.  This function was mainly used to reset the authentication timeout on the PS4, however, it is
 * redundant now as there is no timeout when using a USB HUB on Firmware 1.20 and above.
 * It has been left in for legacy CronusMAX Users
 */
function output_reconnection() {}

/**
 * ps4_authtimeout returns the authentications timeout status on the PS4 in the form of an int.
 * As with output_reconnection, this function is redundant since Firmware 1.20 and above as Partial PS4 cross over
 * support is no longer required.  However, the function has not been removed as legacy CronusMAX users and those not
 * using a USB Hub would still require it
 * @return int The PS4 authentication timeout status. This is a decedent count down with 1 being the last value returned
 *             before an Automatic Reconnection is performed by the CronusMAX PLUS
 */
function ps4_authtimeout() {}

/**
 * The wait command instructs the Virtual Machine within the CronusMAX
 * on how long the last set of commands should be executed for
 * @param int $time The length of time the last commands should be executed for. Represented in milliseconds - range 10 ~ 4000
 */
function wait($time) {}

/**
 * Like the wait command, call is unique to combos and it is not permitted outside of the first level of a combo
 * @param string $combo The name assigned to a combo
 */
function call($combo) {}

/**
 * event_press returns TRUE in the main iteration when a control changes from FALSE to TRUE. Therefore, even if a button
 * is pressed and held down, event_press would only return TRUE at the moment it is pressed and not while the button was
 * held.  This makes it perfect for combos you only wish to run once when a button is pressed
 * @param int $btn
 * @return bool
 */
function event_press($btn) {}

/**
 * event_release is the opposite of event_press, it returns TRUE in the main iteration when a control changes from TRUE
 * to FALSE.  This makes it ideally suited to run code you which you only want run once when a button is released
 * @param int $btn
 * @return bool
 */
function event_release($btn) {}

/**
 * set_val overwrites the current value of a controller entry with the value that is specified in its second parameter.
 * What this means is whatever the output is from the controller for the specified button/axis,
 * the set_val command will overwrite that value with the value you specify
 * @param int $btn
 * @param int $value
 */
function set_val($btn, $value) {}

/**
 * block prevents the forwarding of a controller entry for a set period of time which is set in milliseconds.
 * This time can range from 20 to 4000 milliseconds.
 * It it is extremely useful when you wish to get two uses from a single button
 * @param int $btn
 * @param int $time Length of time in milliseconds to block forwarding for.  Allowed range 20 ~ 4000
 */
function block($btn, $time) {}

/**
 * swap does as the name implies, it swaps the values of two controller entries.
 * This makes it useful for remapping buttons on the fly
 * @param int $btn1
 * @param int $btn2
 */
function swap($btn1, $btn2) {}

/**
 * deadzone adjusts the values of the output to alter the deadzone of two axis. The default deadzone programmed into
 * consoles is 20%, this means a console will ignore any signal from an analogue stick which is below 20%.
 * The CronusMAX PLUS can adjust the output signals relative to the input
 * @param int $stickX a controller entry which represents an X axis
 * @param int $stickY a controller entry which represents a Y axis
 * @param int $zoneX X axis deadzone value / DZ_CIRCLE constant
 * @param int $zoneY Y axis deadzone value / The radius value of the circle
 */
function deadzone($stickX, $stickY, $zoneX, $zoneY) {}

/**
 * stickize transforms the values of a Wiimote IR or mouse input to an analog stick.
 * @param int $identX a controller entry which represents an X axis
 * @param int $identY a controller entry which represents an Y axis
 * @param int $radius The radius value of the circle
 */
function stickize($identX, $identY, $radius) {}

/**
 * ps4_touchpad returns detailed information on the current state of the touchpad. Like get_val, it returns an int.
 * ps4_touchpad can give you information on where two fingers are positioned on the touchpad and their X / Y coordinates
 * This is done via six constants;
 * PS4T_P1 - TRUE if at least one finger is on the touchpad, FALSE if none
 * PS4T_P1X - X axis value of the first finger on the touchpad
 * PS4T_P1Y - Y axis value of the first finger on the touchpad
 * PS4T_P2 - TRUE if two fingers are on the touchpad, FALSE if less than two.
 * PS4T_P2X - X axis value of the second finger on the touchpad
 * PS4T_P2Y - Y axis value of the second finger on the touchpad
 * @param int $touch
 * @return int An int value related to the PS4T_ constant used
 */
function ps4_touchpad($touch) {}

/**
 * ps4_set_touchpad will touch the DualShock 4 touchpad in a specific (X, Y) position
 * @param int $x X position in the DualShock 4 touchpad, ranging from -100 to 100
 * @param int $y Y position in the DualShock 4 touchpad, ranging from -100 to 100
 */
function ps4_set_touchpad($x, $y) {}

/**
 * turn_off will switch off a wireless controller connected to the CronusMAX PLUS input port
 */
function turn_off() {}

/**
 * wii_offscreen checks to see if the Wiimote controller is pointing off screen
 * @return bool TRUE if the Wiimote IR is pointing off screen, FALSE if it is not
 */
function wiir_offscreen() {}

/**
 * returns the current value of a controller entry in the form of an int.
 * This means it returns a number which represents a percentage %
 * @param $btn
 * @return int
 */
function get_val($btn) {}

/**
 * get_lval is similar to get_val with the exception that it returns the value of the specified identifier in the
 * previous iteration (run) of the main loop. This value is also returned as a int and represents a percentage %.
 * However, get_lval gets its data from the input report so, unlike get_val,  is not affected by any code before it.
 * For example, if you were to use the set_val command to overwrite the output of an identifier, get_lval would still
 * return the previous value of said identifier.
 * @param $btn
 * @return int The previous value of the specified identifier.  Can range from -100 to +100 deepening on the entry type
 */
function get_lval($btn) {}

/**
 * get_ptime returns the value in milliseconds of an identifiers state change in the form of a int.
 * What his means is when an identifiers value changes from FALSE to TRUE  or vice versa, the counter for get_ptime on
 * that identifier is reset to 0
 * @param $btn
 * @return int
 */
function get_ptime($btn) {}

/**
 * combo_run does precisely what the name suggests and runs a combo.
 * However, unlike the combo_restart command, it has no effect if the combo is currently running.
 * It will only start a combo is it is not already running
 * @param string $combo The name assigned to a combo
 */
function combo_run($combo) {}

/**
 * combo_running is a function which can be used in your code to check is a combo is running is not.
 * If the combo named in its parameter is running, then it will return TRUE.  If not, it will return FALSE
 * @param string $combo The name assigned to a combo
 * @return bool TRUE if the combo is running, FALSE if it is not
 */
function combo_running($combo) {}

/**
 * As the name suggests, combo_stop will stop a combo if it is currently running.
 * As with combo_run, it has no effect if the combo is not currently running
 * @param string $combo The name assigned to a combo
 */
function combo_stop($combo) {}

/**
 * As the name suggests, combo_restart will restart a running combo.
 * If the combo stated within it's parameters is currently running, it will be restarted from the beginning.
 * If the combo is not currently running, it will be run
 * @param string $combo The name assigned to a combo
 */
function combo_restart($combo) {}

/**
 * get_console returns a value in the form of a int which represents the type of console currently connected to the
 * output port of the CronusMAX PLUS
 * 0 (zero) is returned if no console is connected and a value of 1, 2, 4 or 5 is returned if a console is connected,
 * depending on the type of console connected.
 * To save you from remembering which value relates to which type of controller, 4 constants have been created. They are;
 * PIO_PS3 - Playstation 3
 * PIO_XB360 - Xbox 360
 * PIO_PS4 - Playstation 4
 * PIO_XB1 - Xbox One
 * @return int A value which represents which type of console is currently connected
 */
function get_console() {}

/**
 * get_controller returns a value in the form of a int which represents the controller type currently connected to the
 * input port of the CronusMAX PLUS
 * 0 (zero) is returned if no controller is connected and a value of 1 ~ 5 is returned if a controller is connected
 * depending on the type of controller is connected.
 * To save you from remembering which value relates to which type of controller, 5 constants have been created. They are;
 * PIO_PS3 - Playstation 3 Controller
 * PIO_XB360 - Xbox 360 Controller
 * PIO_WII - Wii Controller
 * PIO_PS4 - Playstation 4 Controller
 * PIO_XB1 - Xbox One Controller
 * return int A value which represents which type of controller is currently connected
 */
function get_controller() {}

/**
 * get_battery returns the battery level, if applicable, of the connected controller in the form on an int ranging
 * from 0 ~ 10.  With 0 being discharged and 10 being fully charged
 * If no battery is connected, for example a wired controller is connected, then it returns 10.
 * @return int A value ranging from 0 (Discharged) ~ 10 (Fully Charged)
 */
function get_battery() {}

/**
 * set_led sets the state of an LED on the controller. The LEDs range from 0 ~ 3.  Four constants have been created to
 * make it easier to remember which value is assigned to which LED;
 * LED_1 - LED 1 / Xbox 360 Quadrant 1
 * LED_2 - LED 2 / Xbox 360 Quadrant 2
 * LED_3 - LED 3 / Xbox 360 Quadrant 3
 * LED_4 - LED 4 / Xbox 360 Quadrant 4
 *
 * An LED can be set to one of four states using this function which range from 0 ~ 3, as shown in the table below;
 * 0 - LED Off
 * 1 - LED On
 * 2 - LED Blink Fast
 * 3 - LED Blink Slowly
 * @param int $led LED
 * @param int $state State
 */
function set_led($led, $state) {}

/**
 * set_ledx is used to Blink and LED a set amount of times. You can blink and led from 0 to 255 times. 0 sets the LED to on
 * @param int $led the identifier of an LED
 * @param int $repeats The number of times to blink the LED
 */
function set_ledx($led, $repeats) {}

/**
 * get_ledx checks to see if an LED is currently being blinked by the set_ledx function
 * @return int TRUE is the LEDs are being blinked by the set_ledx function, FALSE if they are not
 */
function get_ledx() {}

/**
 * reset_leds returns control of the LEDs to the console and disables any current LED states which are being set by the
 * Virtual Machine
 */
function reset_leds() {}

/**
 * set_rumble sets the speed of the chosen rumble motor on the controller
 * The rumble motors are numbered 0 ~ 3.  To make it easier to remember which motor is which,
 * four constants have been created
 * RUMBLE_A - Strong Rumble Motor (Usually the Left Motor)
 * RUMBLE_B - Weak Rumble Motor (Usually the Right Motor)
 * RUMBLE_RT - Right Trigger Motor (Xbox One controllers only)
 * RUMBLE_LT - Left Trigger Motor (Xbox One controllers only)
 * @param int $rumble
 * @param int $speed in %
 */
function set_rumble($rumble, $speed) {}

/**
 * block_rumble does as it implies and blocks any rumble signals to the controller.
 * Once this function is used, it remains active until such time as it is reset in the script or the script is unloaded
 */
function block_rumble() {}

/**
 * reset_rumble returns control of the rumble motors to the console.  It also deactivates block_rumble if it is active
 */
function reset_rumble() {}

/**
 * get_led returns a value in the form of an int which represents the current state of the chosen LED
 * The LEDs range from 0 ~ 3.
 * Four constants have been created to make it easier to remember which value is assigned to which LED
 * LED_1 - LED_4
 * The return value from this function informs you of the current state of the selected LED.
 * The function returns a value ranging from 0 ~ 3
 * @param $led
 */
function get_led($led) {}

/**
 * get_rumble returns the speed of the chosen rumble motor on the controller in the form of an int.
 * The value returned can range from 0 ~ 100 which represents the speed in a percentage ( % )
 * @param $rumble
 * @return int An int ranging from 0 ~ 100 which represents the current speed of the chosen motor
 */
function get_rumble($rumble) {}

/**
 * inv returns the inverted value of an expression or number. This means a positive value will be turned in to a
 * negative value and vice versa, which is the same as multiplying the value by -1.
 * @param int $value
 * @return int $value The inverted value of the expression
 */
function inv($value) {}

/**
 * isqrt returns the square root of a given value. The square root of a value is the value which when multiplied by
 * itself equals the given value.  For example, the square root of 25 is 5  (5 * 5 = 25).
 * The return value is an integer which means any fractions will be dropped
 * @param int $value
 * @return int $value The square root of the given expression
 */
function isqrt($value) {}

/**
 * Sets one bit of a variable based on its bit index
 * @param string $var any defined variable
 * @param int $index index point of the bit to be set, range 0~15
 */
function set_bit($var, $index) {}

/**
 * Clears one bit of a variable based on its bit index
 * @param string $var any defined variable
 * @param int $index index point of the bit to be set, range 0~15
 */
function clear_bit($var, $index) {}

/**
 * Tests a bit index point in a variable to check if it is TRUE or FALSE ( 1 or 0 )
 * @param string $var any defined variable
 * @param int $index index point of the bit to be set, range 0~15
 * @return bool TRUE is the bit is set, FALSE if it is not
 */
function test_bit($var, $index) {}

/**
 * Stores a value in to a variable based on its bit index and a bit mask
 * @param string $var any defined variable
 * @param int $value anything that has a value (constants, variables, functions, expressions, etc...)
 * @param int $index index point of the bit to be set, range 0~15
 * @param int $mask bit mask corresponding to the size, in bits, of the value to store (without shifting)
 */
function set_bits($var, $value, $index, $mask) {}

/**
 * Extracts a balue from a variable based on a bit index and bit mask
 * @param string $var any defined variable
 * @param int $index index point of the bit to be set, range 0~15
 * @param int $mask bit mask corresponding to the size, in bits, of the value to store (without shifting)
 * @return int
 */
function get_bits($var, $index, $mask) {}

/**
 * get_pvar returns the value stored in a Persistent Variable while allowing you to specify the minimum and maximum
 * permissible value and a default value should the value stored be outside of that range.
 * The min, max and default parameters are mainly intended for when you are retrieving values from a Global variable,
 * however, they must still be specified when reading the value of a private variable
 * @param int $pVar A global or private persistent variable constant
 * @param int $minValue The minimum permissible value
 * @param int $maxValue The maximum permissible value
 * @param int $defaultValue The default value to return should the retrieved value be less then the min_value or greater than the max_value
 * @return int The stored value or the default value if the stored one is out of range
 */
function get_pvar($pVar, $minValue, $maxValue, $defaultValue) {}

/**
 * set_pvar stores the specified value in to a Persistent Variable
 * It is important to remember that each time this function is called, data is written to the EEPROM on the
 * CronusMAX PLUS.  The life of an EEPROM is typically rated in the amount of read/write cycles that can be
 * performed and although the EEPROM in the CronusMAX is rated for 1000's of these, you should still ensure that
 * this function is NOT going to called in every iteration of the main loop.  Never use it at the base level of the
 * main and always ensure it is nested within an if statement which will only return TRUE for one iteration,
 * such as event_press
 * @param int $pVar A global or private persistent variable constant
 * @param int $value A value to be stored
 */
function set_pvar($pVar, $value) {}

/**
 * get_rtime returns the elapsed time between the current and previous iteration of the main function.
 * The value returned is in milliseconds
 * @return int The elapsed time, in milliseconds, between main iterations
 */
function get_rtime() {}

/**
 * get_slot returns an int which represents the number of the currently active slot
 * @return int The number of the currently active slot
 */
function get_slot() {}

/**
 * load_slot will attempt to load the slot number specified within its parameter.
 * If there is no script current stored in the specified slot, then it will unload the current slot and load slot 0
 * @param int $slot A value while represents a slot number to load, range 0~9
 */
function load_slot($slot) {}

/**
 * get_ctrlbutton returns the current control button
 * The control button is set in the Device tab within Cronus PRO's Options window.
 * The enable remote control of slow switch on device dictates which button it is set to
 * @return int 0, 1 or 8 depending on the Remote slot settings in device options
 */
function get_ctrlbutton() {}

/**
 * vm_tctrl sets the virtual machine timeout for the next iteration.
 * By default, the virtual machine runs the main loop every 10 milliseconds as it aids stability.
 * You can however adjust how often each main iteration is run.
 * Just be aware than changing this setting may cause instability within your script
 * @param int $value Numeric value to add to the VM base time. Range -9 ~ 10
 */
function vm_tctrl($value) {}